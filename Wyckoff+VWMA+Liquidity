//@version=5
// ======================================================================
// ALL-IN-ONE INDICATOR: Wyckoff + VWMA + Liquidity Spectrum + Heatmap
// Sources (attribution preserved in comments below):
// - Wyckoff Accumulation Distribution (MPL-2.0) © faytterro
// - Volume Weighted Moving Average (VWMA) (TV built-in wrapper)
// - Liquidity Spectrum Visualizer [BigBeluga] (CC BY-NC-SA 4.0) © BigBeluga
// - Liquidity Heatmap [StratifyTrade] (CC BY-NC-SA 4.0) © StratifyTrade


indicator(title="AIO: Wyckoff + VWMA + Liquidity (Spectrum & Heatmap)",
     shorttitle="AIO Wyckoff+VWMA+Liquidity",
     overlay=true,
     max_boxes_count=500, max_labels_count=500, max_lines_count=500, calc_bars_count = 1000)

// ======================================================================
// 1) WYCKOFF ACCUMULATION / DISTRIBUTION  (source: faytterro)
//    License: MPL-2.0
//    Namespacing prefix: w_
// ======================================================================

// Settings
groupWyckoff = "pWyckoff"

// === Genel ayar ===
color_ = input.color(color.white, "Text Color", group=groupWyckoff)

// RSI hesaplama
rsilen = input.int(14, "RSI Length", group=groupWyckoff)
rsi = ta.rsi(close, rsilen)
rsisens = input.int(20, title= "trend Sensitivity", maxval=50, minval=0, 
 tooltip = "When it increases, bull and bear signals decrease and horizontal trend signals increase.", group=groupWyckoff)

utad = rsi<50+rsisens and rsi[1]>50+rsisens
spring = rsi>50-rsisens and rsi[1]<50-rsisens

// Yüksek ve düşük hesaplama fonksiyonları
myhigh(len) =>
    x = array.new_float()
    for i = 0 to len - 1
        array.push(x, high[i])
    array.max(x)

mylow(len) =>
    x = array.new_float()
    for i = 0 to len - 1
        array.push(x, low[i])
    array.min(x)

// Yatay, yükseliş ve düşüş koşulları
side = (rsi < 50 + rsisens and rsi > 50 - rsisens) or (rsi[1] < 50 + rsisens and rsi[1] > 50 - rsisens)
bull = rsi > 50 + rsisens and rsi[1] > 50 + rsisens
bear = rsi < 50 - rsisens and rsi[1] < 50 - rsisens 

boxlen = ta.barssince(side and not side[1])

barcolor(bull ? color.lime : bear ? color.purple : na, offset = -2)

x1 = ta.valuewhen(side and not side[1], bar_index, 0)
x2 = ta.valuewhen(not side and side[1], bar_index[1], 0)-1
y1 = myhigh(math.max(1, boxlen+1))[2]
y2 = mylow(math.max(1, boxlen+1))[2]

// Kutuyu çizme
var box trendBox = na
if side[1] and not side
    trendBox := box.new(x1, y1, x2, y2, color.gray, 1, line.style_solid, extend.none, xloc.bar_index, x1 < x2 ? color.rgb(120, 123, 134, 90) : na, text_color = color.new(color_,80))

var string after_trend = na
if bull
    after_trend := "Accumulation"
else if bear
    after_trend := "Distribution"

if not na(trendBox) and after_trend == "Accumulation"
    box.set_bgcolor(trendBox, color.rgb(76, 175, 79, 95))
    box.set_text(trendBox, "Accumulation")
else if not na(trendBox) and after_trend == "Distribution"
    box.set_bgcolor(trendBox, color.rgb(255, 82, 82, 95))
    box.set_text(trendBox, "Distribution")

pivotLen = input.int(5, "Pivot Length", minval=1)
rsiLow = 50 - rsisens
rsiHigh = 50 + rsisens
offsetVal = -pivotLen

pivotLow = ta.pivotlow(low, pivotLen, pivotLen)
pivotHigh = ta.pivothigh(high, pivotLen, pivotLen)
rsiAtPivot = rsi[pivotLen]

// Flagler
var bool isSCFlag = false
var bool isARFlag = false
var bool isSTFlag = false
var bool isBCFlag = false
var bool isDARFlag = false
var bool isDSTFlag = false

// SC
isSC = pivotLow and rsiAtPivot < rsiLow and not isSCFlag and not spring
plotshape(isSC, "The Selling Climax", location=location.belowbar, style=shape.triangleup, color=color.green, size=size.tiny, offset=offsetVal, text="SC", textcolor=color_, display = display.pane)
isSCFlag := isSC ? true : isSCFlag

// AR
var int scBarIndex = na
if isSC
    scBarIndex := bar_index - pivotLen
isAR = false
if not na(scBarIndex)
    if pivotHigh and (bar_index - pivotLen > scBarIndex) and not isARFlag
        isAR := true
        scBarIndex := na
isARFlag := isAR ? true : isARFlag
plotshape(isAR, "Automatic Rally", style=shape.triangledown, location=location.abovebar, color=color.green, size=size.tiny, offset=offsetVal, text="AR", textcolor=color_, display = display.pane)

// ST (Accumulation)
var int pivotCounter = 0
if pivotLow
    pivotCounter := pivotCounter + 1
if rsiAtPivot < rsiLow
    pivotCounter := 0
isST = pivotCounter == 1 and pivotLow and not isSTFlag 
plotshape(isST,"the Secondary Test", location=location.belowbar, style=shape.triangleup, color=color.green, size=size.tiny, offset=offsetVal, text="ST", textcolor=color_, display = display.pane)
isSTFlag := isST ? true : isSTFlag

// BC
isBC = rsiAtPivot > rsiHigh and pivotHigh and not isBCFlag and not utad
plotshape(isBC,"The Buying Climax", location=location.abovebar, style=shape.triangledown, color=color.red, size=size.tiny, offset=offsetVal, text="BC", textcolor=color_, display = display.pane)
isBCFlag := isBC ? true : isBCFlag

// DAR
var int bcBarIndex = na
if isBC
    bcBarIndex := bar_index - pivotLen
isDAR = false
if not na(bcBarIndex)
    if pivotLow and (bar_index - pivotLen > bcBarIndex) and not isDARFlag
        isDAR := true
        bcBarIndex := na
isDARFlag := isDAR ? true : isDARFlag
plotshape(isDAR,"Automatic Reaction", location=location.belowbar, style=shape.triangleup, color=color.red, size=size.tiny, offset=offsetVal, text="AR", textcolor=color_, display = display.pane)

// DST
var int darBarIndex = na
if isDAR
    darBarIndex := bar_index - pivotLen
isDST = false
if not na(darBarIndex)
    if pivotHigh and (bar_index - pivotLen > darBarIndex) and not isDSTFlag and not isBC
        isDST := true
        darBarIndex := na
isDSTFlag := isDST ? true : isDSTFlag
plotshape(isDST,"The Secondary Test", location=location.abovebar, style=shape.triangledown, color=color.red, size=size.tiny, offset=offsetVal, text="ST", textcolor=color_, display = display.pane)

// Diğer pivotlar (turuncu)
plotshape(pivotLow and not isSC and not isST and not isAR and not isDAR, "pivotHigh", location=location.belowbar, style=shape.triangleup, color=color.orange, size=size.auto, offset=offsetVal, display = display.pane)
plotshape(pivotHigh and not isAR and not isDST and not isBC,"pivotLow", location=location.abovebar, style=shape.triangledown, color=color.orange, size=size.auto, offset=offsetVal, display = display.pane)

// Reset flagler
if bar_index != bar_index[1]
    isSCFlag := false
    isARFlag := false
    isSTFlag := false
    isBCFlag := false
    isDARFlag := false
    isDSTFlag := false


// ======================================================================
// 2) VWMA  (simple wrapper around ta.vwma)
//    Namespacing prefix: v_
// ======================================================================

groupVW = "VWMA"
v_len   = input.int(20, "VWMA • Length", minval=1, group=groupVW)
v_src   = input.source(close, "VWMA • Source", group=groupVW)
v_off   = input.int(0, "VWMA • Offset", minval=-500, maxval=500, group=groupVW)
v_ma    = ta.vwma(v_src, v_len)
plot(v_ma, title="VWMA", color=color.new(color.blue, 0), offset=v_off)

// ======================================================================
// 3) LIQUIDITY SPECTRUM VISUALIZER [BigBeluga]  (CC BY-NC-SA 4.0)
//    Namespacing prefix: bb_
// ======================================================================

// ＩＮＰＵＴＳ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
groupBB = "Liquidity Spectrum [BigBeluga]"
lookback = input.int(200, "LookBack", group=groupBB)
vol_bubles = input.bool(true, "Display Volume Bubles", group=groupBB)
volume_pr = input.bool(true, "Volume Profile", group=groupBB)
liq_levels = input.bool(true, "Liquidity Levels", group=groupBB)

col_up = input.color(#22b16c, "", inline = "colors", group=groupBB)
col_dn = input.color(#dd7e2a, "", inline = "colors", group=groupBB)

// }


// ＣＡＬＣＵＬＡＴＩＯＮＳ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
allow = last_bar_index - bar_index < lookback

display = allow ? display.all : display.none

n_vol = volume / ta.stdev(volume, 200)

size = n_vol >= 1 and n_vol < 2 ? size.small : n_vol >= 2 and n_vol < 3 ? size.normal : n_vol >= 3 and n_vol < 4 ? size.large : n_vol >= 4 ? size.huge : size.tiny

cond0 = n_vol < 1
cond1 = n_vol >= 1 and n_vol < 2
cond2 = n_vol >= 2 and n_vol < 3 
cond3 = n_vol >= 3 and n_vol < 4
cond4 = n_vol >= 4

offset = -lookback-(volume_pr ? 50 : 0)

if barstate.islast
    h_l = array.new<float>()

    for j = 0 to lookback - 1
        h_l.push(high[j])
        h_l.push(low[j])


    bins = array.new<float>(100)

    step = (h_l.max()-h_l.min()) / 100
    var boxes_bins = array.new<box>()
    var poc_lvls   = array.new<line>()

    for b in boxes_bins
        b.delete()

    for l in poc_lvls
        l.delete()

    boxes_bins.clear()
    poc_lvls.clear()

    for i = 0 to 100-1
        bins.set(i, 0)

    for i = 0 to bins.size()-1

        lower = h_l.min() + step * i 
        upper = lower + step 

        for j = 0 to lookback - 1

            if high[j] == h_l.max()
                label.new(bar_index-j, high[j], style = label.style_label_down, text = str.tostring(high[j]), color = col_dn)

            if low[j] == h_l.min()
                label.new(bar_index-j, low[j], style = label.style_label_up,  text = str.tostring(low[j]), color = col_up)

            c = close[j]

            if c >= lower-step and c <= upper+step
                bins.set(i, bins.get(i) + volume[j])

    for i = 0 to bins.size()-1

        lower = h_l.min() + step * i 
        upper = lower + step 
        val = int(bins.get(i)/bins.max() * 50)

   
        col_res_sup = close > math.avg(upper, lower) ? col_up : col_dn

        if volume_pr
        
            vp_col = color.from_gradient(val, 0, 50, color.new(col_res_sup, 90), col_res_sup)

            boxes_bins.push(box.new(bar_index+offset, upper, bar_index+val+offset, lower, bgcolor = vp_col, border_color = color(na)))

        if val > 25 and liq_levels
            
            color_pocs = color.from_gradient(val, 25, 50, color.new(col_res_sup, 90), col_res_sup)
            width = val < 35 ? 1 : val > 35 ? 2 : val > 45 ? 3 : 1
            poc_lvls.push(line.new(bar_index+offset, math.avg(upper, lower), bar_index+5, math.avg(upper, lower), color = color_pocs, width = width))


    box.delete(box.new(bar_index+offset, h_l.max(), bar_index+5, h_l.min(), color.new(chart.fg_color, 50), 1, bgcolor = na)[1])

// }


// ＰＬＯＴ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{

colorr = close > open ? col_up: col_dn
gradient_col = color.from_gradient(n_vol , 0, 5, color.new(colorr, 50), colorr)

display_vol = vol_bubles ? display.all : display.none
plotshape(allow and cond0 ? hlc3 : na, "", shape.circle, location.absolute, gradient_col, 0, "", na, size = size.tiny, show_last = lookback, force_overlay = true, editable = false, display = display_vol)
plotshape(allow and cond1 ? hlc3 : na, "", shape.circle, location.absolute, gradient_col, 0, "", na, size = size.small, show_last = lookback, force_overlay = true, editable = false, display = display_vol)
plotshape(allow and cond2 ? hlc3 : na, "", shape.circle, location.absolute, gradient_col, 0, "", na, size = size.normal, show_last = lookback, force_overlay = true, editable = false, display = display_vol)
plotshape(allow and cond3 ? hlc3 : na, "", shape.circle, location.absolute, gradient_col, 0, "", na, size = size.large, show_last = lookback, force_overlay = true, editable = false, display = display_vol)
plotshape(allow and cond4 ? hlc3 : na, "", shape.circle, location.absolute, gradient_col, 0, "", na, size = size.huge, show_last = lookback, force_overlay = true, editable = false, display = display_vol)

// Plot labels for significant volume levels
if cond4 and allow and vol_bubles
    label.new(bar_index , hlc3, str.tostring(volume, format.volume), xloc.bar_index, yloc.price ,
                 #00000000, label.style_label_center, chart.fg_color, force_overlay = true)
// }

// ======================================================================
// 4) LIQUIDITY HEATMAP [StratifyTrade]  (CC BY-NC-SA 4.0)
//    Namespacing prefix: st_
// ======================================================================

groupST = "Liquidity Heatmap [StratifyTrade]"
dMi = "[HD] Display liquidation levels in a more accurate way\n" + 
         "[Normal] Display liquidation levels in the normal way"

string dM = input.string("HD"    , "Mode     ", options = ["Normal", "HD"]         , group = groupST, inline = "z", tooltip = dMi)
string dS   = input.string("Both", ""         , options = ["Both", "Long", "Short"], group = groupST, inline = "z")

int   LV = input.int  (300       , "Leverage", group = groupST, inline = "1", minval = 25, maxval = 300)
color lC = input.color(#cc00cc , ""        , group = groupST, inline = "1")
color sC = input.color(#ffff00 , ""        , group = groupST, inline = "1")
color pC = input.color(#ffffff , ""        , group = groupST, inline = "1")

bool lB = input.bool(true, "Display Liquidation Bubbles", group = groupST)
bool lL = input.bool(true, "Display Liquidation Levels ", group = groupST)


type bar
    float o = open
    float h = high
    float l = low
    float c = close
    float v = volume
    int   n = bar_index


type bin
    line [] l
    float[] v


bar j = bar.new()

var bin b = bin.new(
       array.new<line >(     )
     , array.new<float>(1, na)
     )

float sma = ta.sma(j.v, 14)

method gC(color css) =>
    color.from_gradient(
           b.v.first()
         , b.v.min  ()
         , b.v.max  ()
         , #ffffff00
         , css
         )


sV(bool fT) =>
    if b.v.size() > 499
        b.v.pop()
    
    if fT
        b.v.unshift(
             dM == "HD" 
                 ? j.v
                 : j.v - nz(j.v[1])
             )


method dL(line[] l, float pos, color css, int width) =>

    if l.size() > 499
        l.pop().delete()

    l.unshift(
         line.new(
               x1    = j.n
             , x2    = j.n
             , y1    = pos
             , y2    = pos
             , xloc  = xloc.bar_index
             , color = css.gC()
             , style = line.style_solid
             , width = width
              )
             )


method uL(line[] l) =>
    for ln in l
        x = ln.get_x2()
        y = ln.get_y1()
        if j.n - 1 == x - 1 and not (j.h > y and j.l < y)
            ln.set_x2(j.n + 1)


draw(int L, bool fT) =>
    sV(fT)
    switch
        lL and fT and j.c > j.o and (dS == "Both" or dS == "Long" ) => 
            b.l.dL(
                   j.l * (1 - 1. / L)
                 , b.v.first() ==    b.v.max() 
                     ? pC 
                     : lC
                 , b.v.first() ==    b.v.max() 
                     ? 3 
                     : b.v.first() > b.v.avg() 
                         ? 2 
                         : 1
                 )
        lL and fT and j.c < j.o and (dS == "Both" or dS == "Short") => 
             b.l.dL(
                   j.h * (1 + 1. / L)
                 , b.v.first() ==    b.v.max() 
                     ? pC 
                     : sC
                 , b.v.first() ==    b.v.max() 
                     ? 3 
                     : b.v.first() > b.v.avg() 
                         ? 2 
                         : 1
                 )
    b.l.uL()


bool fT = j.v > sma 

draw(LV, fT)

bool pV = b.v.first() == b.v.max() 
     ? true 
     : false
bool dL = (dS == "Both" or dS == "Long" ) and lB
bool dD = (dS == "Both" or dS == "Short") and lB


plot(fT and dL and j.c > j.o                              ? j.l * (1 - 1. / LV) : na, color = pV ?                pC.gC() : color.new(lC, 20).gC(), linewidth = 2, style = plot.style_circles, title = "Bubbles")
plot(fT and dL and j.c > j.o and b.v.first() > b.v.avg()  ? j.l * (1 - 1. / LV) : na, color = pV ? color.new(pC, 40).gC() : color.new(lC, 40).gC(), linewidth = 4, style = plot.style_circles, title = "Bubbles")
plot(fT and dL and j.c > j.o and b.v.first() == b.v.max() ? j.l * (1 - 1. / LV) : na, color = pV ? color.new(pC, 60).gC() : color.new(lC, 60).gC(), linewidth = 6, style = plot.style_circles, title = "Bubbles")

plot(fT and dD and j.c < j.o                              ? j.h * (1 + 1. / LV) : na, color = pV ?                pC.gC() : color.new(sC, 20).gC(), linewidth = 2, style = plot.style_circles, title = "Bubbles")
plot(fT and dD and j.c < j.o and b.v.first() > b.v.avg()  ? j.h * (1 + 1. / LV) : na, color = pV ? color.new(pC, 40).gC() : color.new(sC, 40).gC(), linewidth = 4, style = plot.style_circles, title = "Bubbles")
plot(fT and dD and j.c < j.o and b.v.first() == b.v.max() ? j.h * (1 + 1. / LV) : na, color = pV ? color.new(pC, 60).gC() : color.new(sC, 60).gC(), linewidth = 6, style = plot.style_circles, title = "Bubbles")
